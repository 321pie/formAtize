<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="Document.css">
    <title>Document</title>
</head>
<body>
    <div id="home_menu">
        <ul>
            <li><button onclick="handleHomePageClick()">Back</button></li>
            <li id="document_name">Document</li>
            <li><button onclick="handleSaveDocumentClick()">Save</button></li>
        </ul>
    </div>

    <div id="pages">
        <div contenteditable="true"><b><u><i><span style="color: pink; font-size: 24; font-family: Times New Roman">crazy text with all the toppings</span></i></u></b></div>
        <!--TODO: Place <div contenteditable="true"/> in pages in here, then iterate through children for Words()-->
    </div>

    <div id="editing_menus">
        <div id="selected_menu">
            <!--Fill this div with items for the selected menu-->
        </div>
        <ul>
            <li><button onclick="handleBlockMenuClick()">Block</button></li>
            <li><button onclick="handleEditMenuClick()">Edit</button></li>
            <li><button onclick="handleDisplayMenuClick()">Display</button></li>
        </ul>
    </div>

    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <!--<script src="DocumentClasses.js" type="text/javascript"></script>-->
    
    <script type="text/javascript">
        //Retrieve data from local storage and clear for future documents
        const FILE_ID = localStorage.getItem("fileId");
        let DOCUMENT = new Doc(localStorage.getItem("fileName"));
        localStorage.clear();

        //Hide selected menu
        //document.getElementById("selected_menu").style.visibility = 'hidden';
        document.getElementById("selected_menu").innerHTML = '';

        function loadBlock(block) {
            words = block.GetWords();
            let HTMLText = '<div contenteditable="true" class="block">'; //Make block

            //Add Words to block
            for(textIndex=0; textIndex < words.length; textIndex++) {
                textObject = words[textIndex];

                //Populate block with Words objects
                if(textObject.GetBold()) {
                    HTMLText += '<b class="text">';
                }
                if(textObject.GetUnderlined()) {
                    HTMLText += '<u class="text">';
                }
                if(textObject.GetItalicized()) {
                    HTMLText += '<i class="text">';
                }
                HTMLText += `<span class="text" style="color: ${textObject.GetFontColor()}; font-size: ${textObject.GetFontSize}; font-family: ${textObject.GetFont()}">${textObject.GetText()}</span>`;
                if(textObject.GetItalicized()) {
                    HTMLText += '</i>';
                }
                if(textObject.GetUnderlined()) {
                    HTMLText += '</u>';
                }
                if(textObject.GetBold()) {
                    HTMLText += '</b>';
                }
            }
            HTMLText += '</div>';

            return HTMLText;
        }

        //Load document text
        async function loadText(getRemote=true) {
            if(getRemote) {
                let fileId = JSON.parse(FILE_ID);

                let res = await gapi.client.drive.files.get({
                'fileId': fileId,
                'alt': 'media',
                }, {
                'responseType': 'arraybuffer',
                });

                DOCUMENT.FromJSON(JSON.parse(JSON.stringify(res)).result);
            }

            //Create pages/blocks based on DOCUMENT
            let pages = DOCUMENT.GetPages();
            let blocks;
            let HTMLText = '';
            for(pageIndex=0; pageIndex < pages.length; pageIndex++) {
                HTMLText = '';
                blocks = pages[pageIndex].GetBlocks();
                for(blockIndex=0; blockIndex < blocks.length; blockIndex++) {
                    HTMLText += loadBlock(blocks[blockIndex]);

                    /*words = blocks[blockIndex].GetWords();
                    HTMLText += '<div contenteditable="true" class="block">'; //Make block
                    for(textIndex=0; textIndex < words.length; textIndex++) {
                        textObject = words[textIndex];

                        //Populate block with Words objects
                        if(textObject.GetBold()) {
                            HTMLText += '<b class="text">';
                        }
                        if(textObject.GetUnderlined()) {
                            HTMLText += '<u class="text">';
                        }
                        if(textObject.GetItalicized()) {
                            HTMLText += '<i class="text">';
                        }
                        HTMLText += `<span class="text" style="color: ${textObject.GetFontColor()}; font-size: ${textObject.GetFontSize}; font-family: ${textObject.GetFont()}">${textObject.GetText()}</span>`;
                        if(textObject.GetItalicized()) {
                            HTMLText += '</i>';
                        }
                        if(textObject.GetUnderlined()) {
                            HTMLText += '</u>';
                        }
                        if(textObject.GetBold()) {
                            HTMLText += '</b>';
                        }
                    }
                    HTMLText += '</div>';*/
                }
                HTMLText = '<div class="page">' + HTMLText + '</div>';
                document.getElementById('pages').innerHTML += HTMLText;
            }
        }

        //Load document
        document.getElementById('document_name').innerText = DOCUMENT.GetName();
        loadText(); //Must be async

        /*
        *Return to the home page
        */
        function handleHomePageClick() {
            //Change to home page
            window.location.reload();
        }

        /*
        *Save the document
        */
        function handleSaveDocumentClick(save=true) {
            //Load text into Doc class
            DOCUMENT.Clear();
            let pages = document.getElementsByClassName('page');
            for(let pageIndex = 0; pageIndex < pages.length; pageIndex++) {
                let curPage = new Page();
                blocks = pages.item(pageIndex).getElementsByClassName('block');

                for(let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {
                    curPage.AddBlock(blocks.length, new Block([new Words(blocks.item(blockIndex).value)]));
                }

                DOCUMENT.AddPage(DOCUMENT.GetPageCount(), curPage);
            }

            if(save) {
                //Send Document class
                const url = 'https://www.googleapis.com/upload/drive/v3/files/' + JSON.parse(FILE_ID) + '?uploadType=media';
                fetch(url, {
                    'method': 'PATCH',
                    'headers': new Headers({
                        'Authorization': 'Bearer ' + gapi.auth.getToken().access_token, //TODO: Code works, but access token doesn't?
                        'Content-type': 'text/plain'
                    }),
                    'body': `${DOCUMENT.ToJSON()}`
                }).then(alert('File saved.'));
            }
        }

        let slideUp = (target, duration=500) => {
            target.style.transitionProperty = 'height, margin, padding';
            target.style.transitionDuration = duration + 'ms';
            target.style.boxSizing = 'border-box';
            target.style.height = target.offsetHeight + 'px';
            target.offsetHeight;
            target.style.overflow = 'hidden';
            target.style.height = 0;
            target.style.paddingTop = 0;
            target.style.paddingBottom = 0;
            target.style.marginTop = 0;
            target.style.marginBottom = 0;
            window.setTimeout( () => {
                target.style.display = 'none';
                target.style.removeProperty('height');
                target.style.removeProperty('padding-top');
                target.style.removeProperty('padding-bottom');
                target.style.removeProperty('margin-top');
                target.style.removeProperty('margin-bottom');
                target.style.removeProperty('overflow');
                target.style.removeProperty('transition-duration');
                target.style.removeProperty('transition-property');
                //alert("!");
            }, duration);
        }

        let slideDown = (target, duration=500) => {
            target.style.removeProperty('display');
            let display = window.getComputedStyle(target).display;

            if (display === 'none')
                display = 'block';

            target.style.display = display;
            let height = target.offsetHeight;
            target.style.overflow = 'hidden';
            target.style.height = 0;
            target.style.paddingTop = 0;
            target.style.paddingBottom = 0;
            target.style.marginTop = 0;
            target.style.marginBottom = 0;
            target.offsetHeight;
            target.style.boxSizing = 'border-box';
            target.style.transitionProperty = "height, margin, padding";
            target.style.transitionDuration = duration + 'ms';
            target.style.height = height + 'px';
            target.style.removeProperty('padding-top');
            target.style.removeProperty('padding-bottom');
            target.style.removeProperty('margin-top');
            target.style.removeProperty('margin-bottom');
            window.setTimeout( () => {
                target.style.removeProperty('height');
                target.style.removeProperty('overflow');
                target.style.removeProperty('transition-duration');
                target.style.removeProperty('transition-property');
            }, duration);
        }

        let slideToggle = (target, duration = 500) => {
            if (window.getComputedStyle(target).display === 'none') {
                return slideDown(target, duration);
            } else {
                return slideUp(target, duration);
            }
        }

        function handleAddBlockClick() {
            //Save new block to DOCUMENT
            DOCUMENT.AddBlock(new Block(null, document.getElementById("block_type").value, document.getElementById("block_priority").value, document.getElementById("block_alignment").value));

            //Reset and call handleBlockMenuClick()
            document.getElementById("selected_menu").innerHTML = '';
            handleBlockMenuClick();
        }

        function handleCreateBlockTemplateClick() {
            //Populate menu to create new block
            document.getElementById("selected_menu").innerHTML = `
            <div>Please enter a block name: <textarea id="block_type" style="height: 10px; width: 30px;"></textarea></div>
            <div>
                <select name="priority" id="block_priority">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                </select>
            </div>
            <div id="block_alignment">
                <select name="priority" id="block_priority">
                    <option value="left">left</option>
                    <option value="center">center</option>
                    <option value="right">right</option>
                </select>
            </div>
            <div id="submit"><button id="submit_button" onclick="handleAddBlockClick()">Submit</button></div>`;
        }

        function handleCreateBlockClick(block) {
            //Append block to end of last page
            //TODO: Allow for blocks to be added anywhere
            let HTMLText = loadBlock(block);
            let pages = document.getElementsByClassName('page'); //Load pages

            pages[pages.length - 1].innerHTML += HTMLText; //Load block into end of last page
        }

        function handleCleanClick() {
            DOCUMENT.Clean();

            document.getElementById("pages").innerHTML = '';
            loadText();

            //Close Display menu and reopen for reload of blocks
            handleDisplayMenuClick();
            handleDisplayMenuClick();
        }

        function handleEditMenuClick() {
            let target = document.getElementById('pages');

            if (window.getComputedStyle(target).display === 'none') {
                //TODO: Clear div
                document.getElementById("selected_menu").style.visibility = 'hidden';

                return slideDown(target);
            }
            else {
                //TODO: Populate div
                document.getElementById("selected_menu").style.visibility = 'visible';

                return slideUp(target);
            }
        }

        function handleBlockMenuClick() {
            let menu = document.getElementById("selected_menu");

            if(menu.innerHTML != '') {
                //Clear div
                menu.innerHTML = '';
                menu.style.visibility = 'hidden';
            }
            else {
                //Populate div
                handleSaveDocumentClick(false); //Syncs DOCUMENT to actual data

                menu.innerHTML = `
                <div class="grid-container">
                    <div class="grid-item"><button id="create_block_template" onclick="handleCreateBlockTemplateClick()">Create New Block Template</button></div>`;

                let blocks = DOCUMENT.GetBlocks()
                for(blockIndex=0; blockIndex < blocks.length; blockIndex++) {
                    menu.innerHTML += `<div class="grid-item"><button onclick="handleCreateBlockClick(${blocks[blockIndex]})">Create ${blocks[blockIndex].GetType()} Block</button></div>`
                }

                menu.innerHTML += '</div>';
                menu.style.visibility = 'visible';
            }
        }

        function handleDisplayMenuClick() {
            let menu = document.getElementById("selected_menu");

            if(menu.innerHTML != '') {
                //Clear div
                menu.innerHTML = '';
                menu.style.visibility = 'hidden';
            }
            else {
                //Populate div
                handleSaveDocumentClick(false); //Syncs DOCUMENT to actual data
                let wordCount = DOCUMENT.WordCount();
                menu.innerHTML = `
                <div id="word_count">Word Count: ${wordCount[0]}</div>
                <div id="average_word_count">Average Word Length: ${wordCount[1]}</div>
                <div id="clean"><button id="clean_button" onclick="handleCleanClick()">Clean Document</button></div>
                <div>Dropdown to select blocks of a certain type or all blocks</div>
                <div>List of blocks</div>
                `;
                menu.style.visibility = 'visible';
            }
        }
    </script>
</body>
</html>
